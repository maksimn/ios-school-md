# JS in Browser. Обработка событий

Клиентские JavaScript программы используют асинхронную событийную (event-driven) модель программирования.

Тип события (event type) – это строка, которая задаёт, какого рода событие произошло.

```
mousemove keydown load
```

Поскольку тип события – это просто строка, её иногда называют именем события.

Источник события (event target) – это объект, с которым связано (или ассоциируется) данное событие.

Когда мы говорим о событии, мы должны задавать и тип события, и его источник. Например, событие load для Window или событие click для элемента `<button>`.

Обработчик события – это функция, которая вызывается в ответ на некоторое событие.

Объект, связанный с событием (event object) – объект, связанный с конкретным событием и содержащий детали о событии. Такие объекты передаются в виде аргументов обработчикам событий. Все связанные с событиями объекты имеют свойство type, которое определяет тип события и свойство target, которое определяет целевой объект события.

Распространение события (event propagation) – это процесс, благодаря которому браузер решает, на каких объектах будут вызываться обработчики событий. 

Для событий, которые специфичны для единственного объекта (например, load для окна), не требуется распространения.

Но когда определённые типы событий происходят на элементах документа, они распространяются или "всплывают" вверх по дереву документа. Если пользователь проводит мышью над гиперссылкой, сначала возникает событие mousemove на элементе `<a>`, определяющием данную ссылку. Затем оно генерируется на элементах-контейнерах – например, элементе `<p>`, `<div>`, а затем и объекте Document. Иногда удобнее зарегистрировать единственный обработчик на объекте Document или другом элементе-контейнере. Обработчик может остановить пропагацию события, так что оно не будет всплывать далее и запускать обработчики на элементах-контейнерах. Обработчики делают так, вызывая метод или задавая свойство объекта события.

Захват события (event capturing) – это форма распространения события, которая имеет возможность перехватывать (или "захватывать") события до того, как они будут доставлены к их истинному целевому объекту. Способность захватывать или "хватать" события мыши требуется при обработке событий перетаскивания.

Некоторые события имеют связанные с ними действия по умолчанию. Например, когда происходит событие клика по гиперссылке, действие по умолчанию для браузера заключается в том, чтобы проследовать по ссылке и загрузить новую страницу.

## 1. Типы событий

### 1. Унаследованные типы событий.

1) События формы. 

2) События окна.

```
   load unload beforeunload resize scroll
```

3) События мыши.

```
  click dblclick contextmenu
```

4) События клавиш.

### 2. События DOM.

Примеры:

```
focusin focusout focus blur mouseenter mouseleave mouseover mouseout
```

### 3. События HTML5.

1) Ряд событий, связанных с элементами `<audio>` и `<video>`.
2) События перетаскивания.
3) .. 4) ...

### 4. События касания экрана и "мобильные" события.


## 2. Регистрация обработчиков событий

В модели обработки событий по стандарту DOM Level 0 обработчики событий устанавливаются через свойства или атрибуты элементов разметки документа.

```html
   <body onload="doSth()">
```

(нерекомендуемый стиль). Или

```js
   window.onload = doSth;
```

Модель обработки событий DOM Level 0 API очень и очень плохая. Ее мы применять не будем вообще в силу ее бесполезности. 
Модель DOM Level 2 получше, но ей тоже кое-чего не хватает. Она не работает в IE<9.

addEventListener() позволяет задать много обработчиков для события.

```js
   var b = document.getElementById("mybutton");
   b.addEventListener("click", function() { alert("Thanks again!"); }, false);
```

Этот метод дополняется методом removeEventListener().

В стандартной модели событий DOM Level 2 любой объект, который может быть источником события (event target) (это включает объекты window, document, element), определяет метод addEventListener(), который Вы можете использовать, чтобы зарегистрировать обработчик события для данного источника события.

addEventListener() принимает три аргумента. Последним его аргументом является булево значение. Обычно Вы будете передавать false. Если вместо этого Вы передадите true, ваша функция зарегистрируется как обработчик события захвата и она будет вызываться на другой фазе передачи события.

## 3. Вызов обработчика события

### 3.1. Аргументы обработчика события

Обработчики событий обычно (есть одно исключение) вызываются с объектом события как их единственным аргументом. 

Для портируемости с IE8 и ранее следует писать обработчики событий так:

```js
   function handler(event) {
      event = event || window.event;
      // Handler code goes here
   }
```

### 3.2. Контекст обработчика события

Обработчики событий вызываются как методы объекта, на котором они определены. То есть, в теле обработчика события this относится к источнику события.

К сожалению, это неверно для IE метода attachEvent(). 

### 3.3. Область видимости обработчика события.

Как и все функции, обработчики имеют лексическую область видимости. Они исполняются в области видимости, в которой они определены, а не где они вызываются, и они могут получить доступ к любой локальной переменной из этой области видимости.

### 3.4. Возвращаемое значение обработчика.

### 3.5. Порядок вызова.

### 3.6. Распространение события.

"Всплывание" события – это третья фаза распространения события. Вызов обработчиков на источнике события – это вторая фаза. Первая фаза, происходящая даже до того, как вызываются обработчики на event target – это т.н. фаза "захвата". 

Вспомните, что addEventListener() принимает булево значение как свой третий аргумент. Если этот аргумент равен true, то обработчик события регистрируется как обработчик события захвата для вызова на первой фазе распространения события. Захват событий, в отличии от пузырьковых событий, не является универсально поддерживаемым.

Фаза захвата в распространении события – это как "вслытие" в обратном направлении. Захватывающие обработчики объекта Window вызываются первыми, затем захватывающие обработчики объекта Document, потом объекта body, и так вниз по дереву DOM, пока не дойдёт до вызова обработчиков события элемента-родителя для event target. Захватывающие обработчики, зарегистрированные на event target, не вызываются. События захвата дают возможность глянуть на события до того, как они будет доставлены к таргету.

Захватывающий обработчик события может быть использован для отладки, или для подхода с отменой, чтобы отфильтровать события так, чтобы обработчики событий на таргетах никогда не были вызваны. Распространным является их использование в обработке переноса мышью.

### 3.7. Отмена события.

The return value of event handlers registered as properties can be used to cancel the browser’s default action for the event. In browsers that support addEventListener(), you can also cancel the default action for an event by invoking the preventDefault() method of the event object. 

```js
   function cancelHandler(event) {
      var event = event || window.event; // For IE
      /* Do something to handle the event here */
      // Now cancel the default action associated with the event
      if (event.preventDefault) event.preventDefault(); // Standard technique
      if (event.returnValue) event.returnValue = false; // IE
      return false; // For handlers registered as object properties
   }
```

We  can  also  cancel  the  propagation  of  events.  In  browsers  that  support addEventListener(), the event object has a  stopPropagation() method that you can invoke to prevent the continued propagation of the event.

## 4. События загрузки документа

The  DOMContentLoaded  event  is  fired  when  the  document  has  been  loaded  and parsed and any deferred scripts have been executed. Images and asyncscripts may still be loading, but the document is ready to be manipulated.

Реализован следующий важный пример: функция whenReady(), которой можно передать функции для вызова после того, как документ будет пропарсенным и готовым для манипуляций (возможно, что до события load окна).

## 5. События мыши

Пример: a JavaScript function,  drag(), that, when invoked from a mousedown event handler, allows an absolutely positioned document element to be dragged by the user.

## 6. События колесика мыши

Пример: функция enclose(), позволяющая работать с событиями колесика мыши. 
