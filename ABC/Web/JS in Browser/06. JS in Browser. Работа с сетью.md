# JS in Browser. Работа с сетью.

Ajax – термин, описывающий архитектуру веб-приложений, которые отводят важнейшее место сценариям, работающим с HTTP протоколом. Ключевая особенность приложения Ajax в том, что оно использует программу, работающую с HTTP для инициации обмена данными с веб-сервером, не вызывая при этом перезагрузку страниц. К примеру, веб-приложение может использовать технологию Ajax для того, чтобы вести журнал данных о взаимодействии пользователя на сервере или для улучшения времени запуска при помощи отображения сначала простой страницы и затем загрузки дополнительных данных и компонентов страницы по необходимости.

Comet – термин, относящийся к связанной архитектуре веб-приложения, использующей сценарии с HTTP. В некотором смысле Comet противоположен Ajax: в Comet веб-сервер, инициирующий соединение, асихронно отправляет сообщения клиенту. Если веб-приложению нужно ответить на отправленные сервером сообщения, оно может использовать средства Ajax для отправки и запроса данных. В Ajax клиент "вытягивает" данные от сервера, в Comet – сервер "выталкивает" данные клиенту. Другие названия Comet – "Server Push", "Ajax Push" и "HTTP Streaming".

Имеется много способов реализовать Ajax и Comet, и эти лежащие в основе реализации иногда известны как транспорты. Это могут быть элементы со свойством src, способные получать данные (`<img>, <iframe>, <script>`). Реализация транспорта для Comet является более сложной.

Dojo фреймворк реализует транспорт для Comet. Спецификация HTML5 определяет события отправки сервера (server-sent events), являющиеся простым API для Comet в виде объекта EventSource.

Возможно построение высокоуровневых протоколов соединений на основе Ajax и Comet. Эти средства клиент-серверных соединений могут использоваться в качестве основы для механизма RPC (удалённого вызова процедур) или, к примеру, системы событий публикации/подписки. В этой главе такие протоколы не рассматриваются.

В качестве API для работы с программируемым http используется объект XMLHttpRequest. Он работает не только с запросами (request), но и ответами (response). Он является транспортом для Ajax. 

## 1. Использование XMLHttpRequest

Браузеры определяют их HTTP API через класс XMLHttpRequest. Каждый экземпляр этого класса представляет отдельную пару "запрос-ответ", и свойства и методы этого объекта позволяют вам задавать составные части запроса и извлекать данные ответа.

Первое, что нужно для того, чтобы использовать этот HTTP API – это создание объекта XMLHttpRequest

```js
   var request = new XMLHttpRequest();
```

У XMLHttpRequest есть проблемы с IE6.

HTTP запрос состоит из четырех частей:

* Метода HTTP запроса или "глагола" (GET, POST и т. д.)
* Запрашиваемого URL
* Необязательного набора заголовков запроса, которые могут включать информацию об аутентификации
* Необязательного тела запроса

HTTP-ответ, отправляемый сервером, имеет три части

* Числовой и текстовый код статуса, который является индикатором успеха или неудачи запроса
* набор заголовков ответа
* тело ответа

### 1.1. Задание запроса

Следующий шаг – вызов метода open() объекта XMLHttpRequest, чтобы задать две требуемые части запроса – метод и URL:

```js
   request.open("GET", "data.csv");  // Begin a HTTP GET request for the contents of this URL
```

Данный URL является относительным для URL документа, который содержит этот сценарий, вызывающий open(). Если вы задаёте абсолютный URL, то протокол, хост и порт должны в общем случае соответствовать таковым для документа, содержащего данный код. Кросс-доменные HTTP-запросы обычно вызывают ошибку (Но спецификация XMLHttpRequest Level 2 позволяет кросс-доменные запроса в том случае, если сервер в явном виде допускает их).

Следующий шаг в процессе запроса – задание заголовков запроса, если они нужны. POST запросы, например, нуждаются в заголовке "Content-Type" чтобы задать MIME тип для тела запроса:

```js
   request.setRequestHeader("Content-Type", "text/plain");
```

Вам не позволяется самим задать заголовки “Content-Length”, “Date”, “Referer”, или “User-Agent”, XMLHttpRequest добавит их за вас автоматически, и не позволит вам сфальсифицировать их. Также он автоматически обрабатывает cookie, время существования соединения, charset, договоренности о кодировке и т. д.

Вы можете задать заголовок "Authorization" вместе с вашим запросом, но обычно это не нужно. Если Вы делаете запрос к защищенному паролем URL, передавайте username и password как четвертый и пятый аргументы для open(), и XMLHttpRequest задаст соответствующие заголовки для вас. О необязательном третьем аргументе open() мы узнаем ниже.

Заключительный шаг в создании HTTP запроса – задание необязательного тела запроса и отправка его на сервер:

```js
   request.send(null);
```

GET запросы не имеют тела, поэтому вам следует передавать null или опускать аргумент. POST-щапросы обычно содержат тело, и они должны соответствовать заголовку "Content-Type", который Вы задаете с помощью setRequestHeader().

Example 18-1. POSTing plain text to a server

```js
   function postMessage(msg) {
      var request = new XMLHttpRequest(); // New request
      request.open("POST", "/log.php"); // POST to a server-side script
      // Send the message, in plain-text, as the request body
      request.setRequestHeader("Content-Type", // Request body will be plain text
         "text/plain;charset=UTF-8");
      request.send(msg); // Send msg as the request body
      // The request is done. We ignore any response or any error. 
   }
```

### 1.2. Получение ответа

Свойства и методы XMLHttpRequest, относящиеся к http-ответу от сервера:

* Свойства status и statusText возвращают HTTP статус в числовой и текстовой формах. Эти свойства содержат стандартные HTTP значения, такие как 200 и "OK" для успешных запросов и 404 и "Not Found" для URL, которые не соответствуют какому-либо ресурсу на сервере.
* Заголовки ответа можно получить с помощью getResponseHeader() и getAllResponseHeaders(). XMLHttpRequest обрабатывает cookies автоматически – он отфильтровывает cookie-заголовки из набора, возвращенного getAllResponseHeaders() и возвращает null если вы передаете "Set-Cookie" или "Set-Cookie2" в getResponseHeader().
* Тело ответа доступно в текстовой форме через свойство responseText или в виде документа через responseXMLproperty. 

Объект XMLHttpRequest обычно используется асинхронно – метод send() осуществляет возврат немедленно после отправки запроса, и методы ответа и свойства, перечисленные выше, не являются валидными пока не будет получен ответ. Чтобы получить оповещение о том, что ответ готов, вы должны "прослушивать" события readystatechange (или новые события XMLHttpRequest2) объекта XMLHttpRequest. Но чтобы осознать тип события, вы должны сначала узнать значение свойства readyState.

readyState является целым числом, которое задает статус HTTP запроса, и его возможные значения – 

```
0 UNSENT - open() ещё не вызван
1 OPENED – open() уже вызван
2 HEADERS_RECEIVED – получены заголовки ответа
3 LOADING – тело ответа находится в стадии загрузки
4 DONE – запрос завершен
```

Теоретически, событие readystatechange возникает всякий раз, когда изменяется свойство readyState. На практике же данное событие может не порождаться, когда readyState изменяется от 0 до 1. Оно часто запускается, когда вызывается send(), хотя readyState остается при этом в значении OPENED. Все браузеры запускают событие readystatechange, когда readyState изменяет свое значение до 4. Обработчики событий должны всегда проверять значение readyState.

Для "прослушки" событий изменения readystate, задайте свойство onreadystatechange объекта XMLHttpRequest вашим обработчиком события. Вы можете также использовать addEventListener().

Example. Getting an HTTP response onreadystatechange

```js
   // Issue an HTTP GET request for the contents of the specified URL.
   // When the response arrives successfully, verify that it is plain text
   // and if so, pass it to the specified callback function
   function getText(url, callback) {
      var request = new XMLHttpRequest(); // Create new request
      request.open("GET", url); // Specify URL to fetch
      request.onreadystatechange = function() { // Define event listener
         // If the request is compete and was successful
         if (request.readyState === 4 && request.status === 200) {
            var type = request.getResponseHeader("Content-Type");
            if (type.match(/^text/)) // Make sure response is text
               callback(request.responseText); // Pass it to callback
         }
      };
      request.send(null); // Send the request now
   }
```

__1.2.1. Синхронные ответы__

По самой их природе, HTTP запросы лучше всего обрабатывать асинхронно. Тем не менее, XMLHttpRequest также поддерживает синхронные ответы. Если вы передаете false как третий аргумент open(), то метод send() будет блокировать пока не придет ответ. В этом случае не нужно использовать обработчик события, поскольку send() осуществляет возврат, и Вы просто проверяете свойства status и responseText объекта XMLHttpRequest.

Далее в книге приводится синхронный вариант функции getText().

Такого рода синхронности следует избегать.

__1.2.2. Декодирование ответа__

```js
   request.responseText;
   request.responseXML; // возвращает синтаксически разобранный объект document.
```

Структурированные данные можно передавать в формате JSON.

Заголовок "Content-Type" ответа может иметь значения

```
   text/plain, text/html, text/css
```

   содержать "xml" в названии

```
   application/json
   application/javascript text/javascript
```

Можно запросить js-сценарий и затем выполнить его с помощью глобальной функции eval().
Однако это при этом не является необходимым использование XMLHttpRequest, т. к. для подобной загрузки и исполнения достаточно возможностей элемента `<script>`. Помните, что `<script>` может выполнять кросс-доменные запросы, что недоступно для XMLHttpRequest.

Остается вопрос о том, как декодировать приходящие бинарные данные. Для этого см. HTML5.

Заголовок Content-Type в ответе сервера должен быть задан корректно. Если нет, попробуйте метод overrideMimeType(). Этот метод нужно вызвать до вызова send().

### 1.3. Кодировка тела запроса

Http-запросы POST включают в себя тело запроса, которое содержит данные для передачи от клиента к серверу. 

__1) Запросы, закодированные в виде данных формы.__

При отправке формы, данные формы (имя-значение для каждого элемента формы) кодируются в строку и отправляются вместе с запросом. Схема кодировки, используемая для данных формы, относительно проста - … . Для простой формы –

```
   find=pizza&zipcode=02134&radius=1km
```

Формальный MIME-тип для такой кодировки называется application/x-www-form-urlencoded.

Использование XMLHttpRequest предоставляет нам свободу кодировать наши данные так, как мы хотим.

__2) Запросы, закодированные в формате JSON.__

Example 18-7. Making an HTTP POST request with a JSON-encoded body

```js
   function postJSON(url, data, callback) {
      var request = new XMLHttpRequest(); 
      request.open("POST", url); // POST to the specified url
      request.onreadystatechange = function() { // Simple event handler
         if (request.readyState === 4 && callback) // When response is complete
            сallback(request); // call the callback.
      };
      request.setRequestHeader("Content-Type", "application/json");
      request.send(JSON.stringify(data));
   }
```

__3) Запросы в формате XML.__

Если вы передаете к метод send() XML документ не задавая заголовок "Content-Type", то объект XMLHttpRequest автоматически задаст соответствующий заголовок для вас. Аналогично, если данному методу передать строку, то будет заголовок со значением "text/plain; charset=UTF-8".

__4) Отправка файла на сервер.__

Обычно это формы с элементом `<input type="file">`, отправляющие файл в теле запроса POST. Однако XMLHttpRequest 2 API позволяет загружать файлы передавая объект File методу send().  

В браузерах, поддерживающих объекты File, каждый элемент `<input type="file">` имеет свойство files, являющееся array-like объектом объектов File. Некоторый доступ к файлам есть и через drag-and-drop API. 
__5) multipart/form-data.__

Когда HTML-формы включают в себя элементы загрузки файлов (и другие), браузер не может использовать обычную кодировку форм и делает POST формы используя content-type "multipart/form-data".

XHR2 определяет новый FormData API, делающий тела multipart запросов проще. 

1. Создание объекта с помощью конструктора FormData.
2. Вызов append() метода, чтобы добавлять отдельные части (строки, объекты File и Blob).
3. Передача объекта в send().

### 1.4. События выполнения http-запроса.

Имеется "новый" (учитывая 2011-й год издания книги) набор событий, происходящих в ходе прогресса http-запроса.

Событие loadstart, progress, load.

Завершенный запрос – не обязательно успешный запрос, поэтому нужно проверять свойство status XHR.

Есть 3 варианта того, как запрос может потерпеть неудачу, и 3 соответствующих события. 

```
   timeout – если время запроса истекло.
   abort – если запрос прерван.
   error – ошибки сети.
```

Для прослушивания этих событий можно использовать addEventListener() объекта XHR. 

Объект события для данных событий имеет 3 полезных свойства вдобавок к обычным type и timestamp.

```
   loaded – количество переданных байт.
   total – полное число байт, которые должны быть переданы;
   lengthComputable – true если длина содержимого известна и false в противном случае.
```

__1.4.1 События выполнения загрузки (upload)__

У объекта XMLHttpRequest есть свойство upload для мониторинга событий загрузки на сервер. Для него определены все события выполнения http-запроса, кроме onreadystatechange. К ним всем тоже можно применять addEventListener().

Для XMLHttpRequest объекта x можно задать 

```js
   x.onprogress 
```

для мониторинга хода выполнения запроса загрузки данных с сервера и 

```js
   x.upload.onprogress 
```

– для мониторинга хода загрузки данных на сервер.

Пример: представление пользователю отклика на ход загрузки на сервер (1,5 страницы кода).

### 1.5. Прерывание запросов и истечение времени

```js
   request.abort()
```

прерывание запроса.

```
   timeout
```

свойство, задающее время в миллисекундах с начала запроса, после которого он будет автоматически прерван.

```
   ontimeout 
```

задает обработчик события.

## 1.6. Кросс-доменные http-запросы

Объект XMLHttpRequest является частью политики ограничения домена (same-origin policy) и он обычно может производить запросы только к серверу, с которого использующий его документ был загружен. При этом запрещаются некоторые виды вполне "законных" кросс-доменных запросов. Кросс-доменные URL могут быть в элементах `<form>` и `<iframe>`, и браузер отобразит результирующий кросс-доменный документ. Но по причине политики ограничения домена браузер не позволит исходному сценарию исследовать содержимое данного кросс-доменного документа. С объектом XMLHttpRequest содержимое документа всегда проявляется через свойство responseText, так что политика ограничения домена не может позволить XHR делать кросс-доменные запросы.

Заметим, что элемент `<script>` никогда не был предметом политики ограничения домена: он будет загружать и выполнять любой сценарий независимо от его происхождения. Эта свобода выполнения кросс-доменных запросов делает данный элемент привлекательным Ajax-транспортом, альтернативным к XMLHttpRequest.

XHR2  позволяет кросс-доменные запросы к сайтам, которые принимают их с помощью отправки соответствующих CORS (Cross-Origin Resource Sharing) заголовков в их HTTP ответах. В этом плане Вам, как веб-программисту, не нужно делать ничего дополнительно.

В таких кросс-доменных запросах никогда не будут отправлены имя пользователя и пароль, обычно они также не включают пользовательские cookie и HTTP аутентикацию. Если вы хотите, чтобы запросы с такими данными удались, нужно установить request.withCredentials = true перед вызовом send().

Пример 18-13: ненавязчивый JS код, который использует объект XMLHttpRequest для совершения запроса HEAD для загрузки типа, размера и информации о дате, касающихся ресурсов, на которые указывают ссылки <a> документа.

### 2. Выполнение <http> запросов при помощи элемента <script>: JSONP

Элемент `<script>` может использоваться в качестве транспорта для Ajax – просто задайте атрибут src и браузер сгенерирует запрос, загружающий заданный URL. Преимущества: ограничения доменов здесь нет; элементы <script> автоматически декодируют (т.е. исполняют) тело http-ответа, содержащее данные в формате JSON. Этот способ называют JSONP.

Предположим, вы написали сервис, который обрабатывает запросы GET и возвращает данные в формате JSON. Документы того же домена могут использовать этот сервис с помощью XMLHttpRequest и JSON.parse() [см. код Примера 18-3]. В случае допустимости CORS – то же самое. Если же эти варианты не работают, то к сервису можно получить доступ через `<script>`. Браузер выполнит ваш код. При этом данные JSON остаются данными, и ничего более. 

Здесь появляется буква P аббревиатуры JSONP. При вызове через элемент `<script>` ваш сервис должен "создать подложку" для своего ответа, окружив его круглыми скобками и префиксом в виде имени JS функции. Т.е. вместо отправки данных в виде просто JSON

```
   [1, 2, {"buckle": "my shoe"}]
```

ответ отправляют в виде JSON с подложкой:

```js
   handleResponse(
      [1, 2, {"buckle": "my shoe"}]
   )
```

В качестве тела элемента `<script>` этот ответ "с подложкой" выполняет нечто полезное: он работает с данными JSON, являющимися не более чем JS-выражением и затем передает их функции handleResponse(), которая, как мы полагаем, должна быть определена в документе и делает нечто полезное с этими данными.

Чтобы эта система работала, у нас должен быть некоторый способ сообщить сервису о том, что он вызывается из элемента `<script>` и должен отправить ответ в виде JSONP вместо простого JSON. Это можно сделать добавлением параметра запроса к URL, например ?json или &json. На практике службы, которые поддерживают JSONP, не требуют, чтобы клиент реализовал функцию с именем типа "handleResponse". Вместо этого они используют значение параметра запроса, чтобы позволить клиенту определить имя функции, и затем использовать это имя функции как подложку для ответа. В примере 18-14 используется параметр запроса, названный "jsonp" для задания имени функции обратного вызова. Многие сервисы, поддерживающие JSONP, распознают это имя параметра. Другое распространенное имя – "callback".

В Примере 18-14 определяется функция getJSONP(), которая выполняет JSONP запрос. 

### 3. Comet с событиями отправки сервера

Здесь есть объект EventSource, который делает написание Comet-приложений тривиальным. Просто передайте URL конструктору и слушайте события message:

```js
   var ticker = new EventSource("stockprices.php"); 
   ticker.onmessage = function(e) {
      var type = e.type; 
      var data = e.data;
      // Now process the event type and event data strings.
   }
```

Свойство data объекта события содержит любую строку, которую может отправить сервер.

Протокол события отправки сервера (server-sent event) является прямолинейным. Клиент инициирует соединение с сервером (когда он создает объект EventSource) и сервер поддерживает соединение открытым. Когда происходит событие, сервер записывает строки текста в соединение. Событие, движущееся по проводу, может выглядеть так:

```
    event: bid  sets the type of the event object
    data: GOOG  sets the data property
```

Одним очевидным приложением архитектуры Comet является онлайн-чат. Чат-клиент может отправлять новые сообщения в комнату чата с помощью XMLHttpRequest, и может подписаться на поток болтовни с помощью объекта EventSource. Это показывает пример 18-15.

В момент написания 6-го тома Фланагана EventSource поддерживался Хромом, Сафари, а также ожидался релиз в Mozilla сразу после версии FireFox 4.0. В FireFox из-за специфики реализации XMLHttpRequest было относительно легко эмулировать EventSource через XMLHttpRequest [Example 18-16]. В остальных браузерах это не работало. 

Исследование Comet здесь завершается примером кода для сервера [Пример 18-17]. Кастомный HTTP сервер написан на серверном node.js. Когда клиент делает запрос к корневому URL "/", сервер отправляет чат-клиенту код, показанный в примере 18-15 и в коде эмуляции из примера 18-16. Когда клиент делает запрос GET к URL "/chat", он сохраняет поток ответа в массиве и держит соединение открытым. И когда клиент совершает запрос POST к "/chat", он использует тело запроса в качестве сообщения чата и записывает его с префиксом "data:" для событий отправки сервера, для каждого из открытых потоков ответа (response stream). Если у Вас установлена Нода, вы можете запустить этот пример локально. Он прослушивает порт 8000, так что после запуска сервера вы направите браузер на http://localhost:8000 для соединения и начнёте чатиться сами с собой.
