# JS. Функции.

## 2. Вызов функции

### 2.4. Косвенный вызов функции

Один из вариантов вызова функции – это её косвенный вызов с помощью методов apply() и call() объекта Function.

Оба метода позволяют явно задать значение this для данного вызова, то есть вы можете вызвать любую функцию как метод любого объекта, даже если она в действительности не является методом этого объекта. Они также позволяют задать аргументы для вызова. Метод call() использует свой собственный список аргументов в качестве аргументов заданной функции, а метод apply() ожидает в качестве аргументов массив значений.

## 3. Аргументы и параметры функции

## 3.2. Списки аргументов переменной длины, объект Arguments

В теле функции идентификатор arguments относится к объекту Arguments для данного вызова. Объект Arguments – это подобный массивам объект, который позволяет переданные в функцию аргументы извлекать по их числовым индексам, вместо извлечения по именам. Можно понимать arguments как массив аргументов функции.

__3.2.1. Свойства caller и callee объекта Arguments.__

В строгом режиме ES5 эти свойства сгенерируют TypeError, если вы попытаетесь считать или записать их. Вне строгого режима свойство callee относится к выполняемой текущей функции. caller – нестандартное, но реализуемое свойство, которое относится к функции, которая вызвала первую. Свойство caller предоставляет доступ к стеку вызовов, а свойство callee иногда полезно для того, чтобы безымянные функции могли вызывать сами себя рекурсивно.

```js
var factorial = function(x) {
   if (x <= 1) return 1;
   return x * arguments.callee(x-1);
};
```

## 4. Функции как значения

Поскольку функции в JS являются объектами, их можно рассматривать и как значения, и как контейнеры для свойств. Функция может быть 

* присвоена переменной,
* храниться как свойство объекта или элемент массива
* передаваться в качестве аргумента в функцию
* возвращаться из функции и т. д. 

## 5. Функции как пространства имён

JS характеризуется функциональной областью видимости: переменные, определённые внутри функции, видны в пределах всей функции (включая вложенные функции), но не существуют вне этой функции. 

В JS не определён какой-либо способ объявить переменные, которые сокрыты внутри отдельного блока кода, и по этой причине иногда полезно определить функцию, которая просто является временным пространством имён, в котором Вы можете определять переменные без загрязнения глобального пространства имён.

Выделить отдельный модуль кода можно следующим образом

```js
(function() { 
   // Здесь находится сокрытый код модуля
}()); 
```

Это выражение является идиомой JS-программирования.

## 6. Замыкания

Определение. Лексическая область видимости (lexical scoping) – означает, что язык использует для функции тут область видимости переменных, которая является действительной там, где функции определена, а не там, где функция вызывается. Это имеет место в JS.

Для реализации данного принципа в JS объект функции должен содержать не только код функции, но и ссылку на текущую цепочку областей видимости.

Определение. Замыкание – это объединение объекта функции с областью видимости (набором привязок переменных), в которой разрешены (resolved) переменные данной функции. 

В JS все функции являются замыканиями. 

В большинстве случаев функции используются так, что замыкания для них не играют роли. Замыкания интересны когда функция вызывается из другой цепочки областей видимости, отличной от той, где функция была определена. Обычно это возврат объекта вложенной функции из той функции, где данная вложенная функция была определена. По своей сути, замыкания удивительны и сильны тем, что они захватывают привязки локальных переменных (и параметров) внешней функции, в пределах которой они определены.

Пример: счётчик вызовов функции, реализованный без замыкания

```js
uniqueInteger.counter = 0;
function uniqueInteger() {
   return uniqueInteger.counter++; // Increment and return counter property
}
```

Недостаток этого подхода в том, что ошибочный или вредоносный код может сбросить счётчик или установить его на нечисловое значение, что нарушит сам смысл определения этой функции.
Замыкания захватывают локальные переменные отдельного вызова функции и могут использовать эти переменные как закрытое состояние. Вот переписанная функция с замыканием:

```js
var uniqueInteger = (function() { // Define and invoke
   var counter = 0; // Private state of function below
   return function() { return counter++; };
}());
```

Замыкания можно также использовать и с get- и set-методами свойств.

Важно помнить при написании замыканий, что this не является переменной. Каждый вызов функции обладает значением this, и замыкание не имеет доступа к значению this внешней функции, если внешняя функция не сохранила это значение в переменной

```js
var self = this; 
```

Привязка значения arguments похожа. arguments автоматически объявляется для каждого вызова функции. Поэтому его нужно сохранять в переменной внутри внешней функции, чтобы она могла использоваться вложенной функцией

```js
var outerArguments = arguments; 
```

## 7. Свойства, методы и конструктор класса Function()

Функции в JS являются объектами, поэтому всё это у них есть.

1) length – свойство, только для чтения, возвращающее арность функции – количество параметров, которых она определяет в её списке параметров.
Примечание: arguments.length легко может отличаться от arguments.callee.length. 

2) prototype – свойство, возвращающее ссылку на объект-прототип.

3) call() – метод, чтобы вызвать функцию func1() как метод объекта obj
4) apply() – почти то же, что и call()

```js
func1.call(obj)
func1.apply(obj)
```

С аргументами

```js
func1.call(obj, 1, 2)
func1.apply(obj, [1, 2])
```

5) bind() – метод ES5, привязывает функцию к объекту. То есть делает функцию методом данного объекта. Он также выполняет "частичное приложение": любые аргументы, которые вы передаёте bind() после первого, привязываются вместе со значением this. Частичное приложение является распространённым подходом в функциональном программировании и иногда называется "currying".

6) toString() – в основном возвращает полный исходный код функции.

Конструктор Function()

Функции могут создаваться в виде предложения определения функции или выражения литерала функции. Но также их можно определить с помощью конструктора Function(), например

```js
var f = new Function("x", "y", "return x*y;");
```

Заметим, что конструктор функции сам по себе создаёт анонимную функцию.

Объекты, вызываемые как функции (callable objects)
Объект, вызываемый как функция, может быть вызван через выражение вызова функции.
В JS таких вещей нужно избегать.

## 8. Функциональное программирование

Глава предназначена для "расширения сознания", а не для предписания функционального программирования как хорошего стиля программирования на JS
