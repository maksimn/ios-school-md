# Архитектура RIBs

## Зачем была создана эта новая архитектура, а не взяты MVC, MVP, MVVM, VIPER?

Проект увеличился с команды из 1-2 разработчиков до команды из сотен разработчиков. Это создало проблемы. 

(Unit и UI тестов не было, т.к. на них не хотели тратить время).

Возникла ситуация, когда проект желательно было переписать с нуля, чтобы с его можно было развивать далее годы вперед.

Архитектура должна была лучше описывать состояния приложения в виде конечного автомата. Текущее решение не очень хорошо работало, нужно было переписать полностью.

## Что хотели получить от переписывания проекта

* 99.99 процентов надежности основных потоков бизнес-логики приложения. Включение отката потока к гарантированно рабочему состоянию приложения. Это в принципе не совсем задача архитектуры, но выбор архитектуры может помочь.
* Поддержание роста системы на годы вперед. Сужение функциональности и слабая связанность в максимальной степени. 
* Постановка проектирования архитектуры модулей и написания кода на чёткие рельсы.
* Автоматическая поддержка логирования, аналитики, дебага и трейсинга ("мониторинг").
* Убрать риски экспериментов. 
* Непревзоденную производительность и плавную деградацию на слабых устройствах и сетях.
* Общность архитектуры и подходов для iOS и Android. Общность бизнес-логики.

MVC, MV*, VIPER не подошли для целей компании. Эти подходы основаны на View и тогда приходится делать интеграцию в одной точке, что на больших масштабах Убера приводит к беспорядку. Недостаток их в том, что в них представление и бизнес-логика залочены друг на друга.

-> Возник RIBs.

По архитектуре также возник вопрос с работой со сложными анимациями, координацией нескольких view.

```
RIBs Arch (Core Arch)
  |
  |
Application Framework (Uber-specific use case)
```

RIBs = Router, Interactor, Builder (+ Presenter, View).

Решение проблем

* Massive VC
* запутанных конечных автоматов, описывающих поток бизнес-логики приложения, переходы от одного состояния к другому.

Состоянию нужно знать о соседних состояниях, к которым могут произойти переходы, и которые нужно обработать.

Общее решение двух проблем -- дерево состояний.

Состояние всего приложения описывается как дерево. Дерево состояний основывается на бизнес-логике приложения, а не на его views. RIB может иметь свой view, но не обязательно.

RIB не знает своего родителя, но может знать только, каких потомков он присоединяет к себе.


