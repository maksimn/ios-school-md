# iOS-Dev. 07.

# Обзор MVC, MVVM, MVP, VIPER, Чистая архитектура.

Вопросы: 1) что такое архитектура MVC/MVVM/MVP/VIPER etc.?

2) В чём отличие одной архитектуры от другой? В чем особенность архитектуры Х?

3) Что такое Чистая архитектура?

---

В iOS проблемы с классическим MVC, потому что в нем модель и контроллер очень сильно связаны. Реально такой паттерн называется MVA - Model-View-Adapter.

---

Механизмы оповещения об изменениях модели: 1) делегаты, 2) блоки, 3) KVO - Key-value observer в Obj-C, didSet для свойств в Swift.

---

В MVP нужна также 4-я сущность для работы паттерна -- Assembly, где происходит сборка частей паттерна в единое целое. Вызывается в тот момент, когда нужен определенный экран (этот момент самим паттерном не определяется). 

---

MVP vs MVVM -- View в MVP пассивно, в MVVM -- нет.

VM тоже активна, как презентер; разница в том, что то, что в презентере делается через методы, во ViewModel делается через биндинги.

---

VIPER -- это реализация Clean Architecture для мобильной разработки под iOS.

---

В СБОЛе ориентация на чистую архитектуру. Она подходит для него.

Как устроен СБОЛ ...

VIPER (interactor)
↓
[Service Layer]
↓
[Core Layer] + [Helpers]

---

Объекты Core Data не относятся к View. Они на уровне чтения данных, работы с данными БД. А между уровнями они переходят через DTO (structs).

На уровне View ничего не знают про JSON, XML, источники данных.

Сервис состоит из набора хелперов.

Assembly все это собирает.

---

Бывают координаторы вместо роутеров. MVP + Coordinators (вместо VIPER).

---

Другой вид архитектур - однонаправленные архитектуры.

---

СБОЛ - модульная архитектура. Про СБОЛ.

---

В бизнесе архитектура приложения глобально определяется 1) опытом, 2) организацией, оргструктурой, 3) бизнесом, бизнес-требованиями.

---

БД в iOS - Core Data, Realm.

---

# Внедрение зависимостей

В моем "реальном проекте" Елизаров (наследник "Яндекс.Исполнитель" из Яндекс-Мобилизации 2016) я заметил 3 способа внедрения зависимостей:

1) внедрение через сборщик архитектуры -- части паттерна MVP внедряются через методы класса-сборщика `MVPMusicAssembly`;

2) внедрение через самописный контейнер зависимостей `DIContainer`;

3) внедрение через использование простой фабрики: разные способы итерации по трекам (удовлетворяющие протоколу `TrackIterator`) внедряются через вызов метода простой фабрики.
