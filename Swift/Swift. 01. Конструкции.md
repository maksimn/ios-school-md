# Swift

Есть кортежи.

```swift
let someTuple = (324, "Some string")

let a = someTuple.0
let str = someTuple.1
```

---

Зачем нужен лейбл для параметра функции?

---

`mutating` - помечает методы __структуры__, изменяющие ее поля.

---

Свойства и методы с ключевым словом `class` – это почти как `static` – свойства и методы уровня класса, но могут быть переопределены в производных классах. Это может применяться в UIKit, где переопределяется `CALayer`.

---

## Change observers

```swift

var prop: SomeProp {
  willSet {
    print(newValue)
  }
  didSet {
    print(oldValue)
  }
}
```

## Key paths

Это ссылка на свойство типа:

```swift
struct Person {
  let name: String
  var age: Int
}

let bob = Person(name: "Bob", age: 25)
let path = \Person.age

let bobAge = bob[keyPath: path] // 25
```

KeyPath – отдельный тип в свифте.

---

## Ranges

```swift
for i in 1..<10 {

}

for i in 0...10 {

}
```

__*One-sided ranges*__ (односторонние диапазоны):

```swift
let range = str.startIndex...
let range = ..<str.endIndex
```

---

__Конструкция defer__

```swift
func foo() {
  door.open()
  defer {
    door.close()
  }

  // some code...
}
```

## Optionals

Optional в Swift - это либо nil, либо value.

Optional `?` имеет смысл для переменных и констант.
 
Optional (когда есть вопросик) означает "не всегда".

Non-optional - "всегда значение заданного типа".

Optional - это некоторая структура-обёртка над типом (этот генериковый enum – value-тип!):

```swift
enum Optional<Wrapped> {
  case none
  case some(Wrapped)
}

var vo: UIView?
var vo1: Optional<UIView> // эквивалентно предыдущей строке
```

Для получения полей используется оператор "?." - это первый способ, для получения значений с проверкой на `nil`.

2-й способ: получение значения без проверки —

```swift
var frx = vo?.frame
var fry = vo!.frame
```

В случае 2: если значение есть, то работа с ним ведётся как с non-optional.

Этот подход называется force-unwrapping для optionals. Если мы не боимся и уверены, что значение в optional'e есть, то можем использовать этот подход. Но это не очень правильный подход, потому что если значения не будет (т. е. оно равно nil), то получим крэш в рантайме. А такое нам не нужно.

Вместо force-unwrap'a используем конструкцию if let, `if let` - это для optional binding. Это не обычный if. Что это вообще такое?

```swift
if let <constantName> = <someOptional> {
	<statements>
}

if let actualNumber = Int(possibleNumber) {
	print("The string \"\(possibleNumer)\" has an integer value of \(actualNumber)")
} else {
	print("The string \"\(possibleNumer)\" could not be converted to integer")
}
```

```swift
if let view1 = view1 {
    // попадем в этот блок только если view1 != nil и внутри него переменная автоматически будет non-optional
}
```

Этот подход лучше. Также можно использовать конструкцию guard let:

```swift
guard let vx1 = view1 else {
    // блок для случая no value
}
```

Она удобна для проверки и разыменования optional-значения на входе в функцию. Это хорошо для реализации golden path / happy path.

## Swift. ООП.

Ключевые слова `class / static` - оба применяются для статических свойств класса. По соглашению `class` - для переменных, `static` - для констант.

Бывают вычислимые свойства:

```swift
class Car {
    ...
	var buyTimestamp: TimeInterval {
		set {...}
		get {...}
	}

	var someGetter: Int { // просто геттер
		return 23;
	}
}
```

Модификаторы доступа в Swift:

* `private(set)` - для свойства только на чтение извне.
* `fileprivate` - внутри файла - public, а для других файлов - `private`.
* `internal` - по умолчанию - открытость в модуле.

В Swift есть деинициализаторы классов:

```swift
class Car {
	deinit {

	}
}
```

(непонятно, зачем они нужны).

## Swift. Управление памятью.

Для этого есть ключевое слово —

`weak` - для пометки ссылок. Нужно для устранения retain-циклов, приводящих к утечкам памяти (см. Obj-C). В Swift это широко используется.

---

## Swift. Структуры

У них есть инициализаторы, генерируемые компилятором 

```swift
struct SomeStruct {
	let name: String
	let something: String
}

let v = SomeStruct(name: "SomeName", something: "SomeString")
```

поля в ините заданы в порядке, в котором объявлены в структуре.

Reference types - классы (живут в куче)

Value types - структуры (живут в стеке)

Еще у структур нет деинициализаторов.

При изменении поля структуры создается новый экземпляр.

Структура - идеальный кандидат для создания иммутабельных DTO (data-transfer object).

Также структуры в силу этого потокобезопасны.

Контракты вообще лучше делать иммутабельными - это спасает от многих ошибок.

---

## Swift. Перечисления

Благодаря ним можно создавать понятные и самодокументированные API.

Имя структуры - можно использовать как имя типа

Элементы перечисления - как значения данного типа.

```swift
let planet = Planets.mars // с маленькой буквы!
```

По умолчанию никакое значение типа int не ставится в соответствие элементу перечисления.

Что такое __raw values__? Для структуры можно дополнительно объявить тип сопоставленного значения (тип raw value для структуры) и сопоставить каждому элементу перечисления значение этого типа.

```swift
p.rawValue // доступ к raw value
```

В элементе также можно иметь хранимые значения:

```swift
// это подходит для написания сетевого слоя
enum Result {
	case success(data: Data, headers: [String: Any])
	case failure(error: Error)
	
	var rawValue: String { // хотим к хранимому значению иметь сырое типа строка
		switch self { 
			case .success return "success"
			case .failure return "failure"
		}
	}
}
```

Сырое и хранимое значение в элементе нельзя иметь одновременно. Но это можно обойти.

Элементы перечисления являются полноценными объектами, для них можно объявлять вычислимые свойства и функции (таким же образом, как для класса/структуры).

Чтобы получить в свое использование хранимые значения элемента перечисления, необходимо воспользоваться оператором switch:

```swift
let res: Result = ..
switch res {
case let .success(data, headers): print(data, headers)
case let .failure(error): print(error)
}
```

---

Расширение в Swift может иметь модификатор доступа. Например, `private extension` будет доступен только в файле, где он задан, а также это сэкономит время компиляции.

---

## Замыкания

Кложура – блок кода, который можно присвоить переменной, передать функции в качестве параметра и т. д. и который захватывает контекст, в котором он был объявлен.

В свифт замыкание – это "1st class citizen". 

```swift
let greetings = { (_ p: String) -> Void in 
	print("Hi \(p)")
}

let greetings: (String) -> Void = { name in
	print("Hi \(name)")
}
```

Если тип захвата внешней переменной не указан, то при использовании она будет захвачена по сильной ссылке.

Явный захват "по значению":

```swift
var printer = Printer()

let sayHello = { [printer] in
	printer.print("Hi")
}

// Захват по слабой ссылке
let sayHello = { [weak printer] in
	printer?.print("Hi") // переменная приводится к optional
}
```

Если вместо weak сделать unowned - это для того случая, когда Вы не хотите приведения к optional, и знаете, что переменная будет жить достаточно долго до момента ее использования. Это может привести к падению в рантайме.

Escaping closure - если надо сохранить замыкание как поле класса или выполнить асинхронный вызов - могут быть вызваны вне scope, в котором объявлены. Здесь есть вопросы управления памятью и работы с потоками. Такие замыкания часто вызываются для т.н. completion handler'ов, функций обратного вызова.

При использовании в классе self'а внутри замыкания можно получить retain-cycle - например, при сохранении замыкания как поля класса. Компилятор не напишет вам предупреждения. Для решения этой проблемы надо захватывать внутри замыкания self по слабой ссылке и проверять на optional.

Non-escaping closure - по умолчанию: вызываются и возвращаются в рамках scope, в котором они объявлены.

В замыкании можно указать __*список захвата*__ `[var1, var2, ...]`. Он означает, что при передаче указанной переменной из внешнего контекста фактически создаётся _копия_ данной переменной.

---

В Swift функция может иметь несколько возвращаемых значений

---

## Оператор switch

Это объемная тема, switch здесь имеет широкие возможности и применения по сравнению со старыми языками.

Оператор switch в swift позволяет делать pattern matching

```swift

```

Switch не требует break для прерывания. Для аналога поведения как в С++ используется `fallthrough`.

`case`

`case is`

`case let`

`case let as`

`case <диапазон>`

Switch, использующий переопределение оператора `~=`

---

SIL - Swift Intermediate Language
