# Swift. Structured concurrency.

Structured concurrency построена на идее "структурного программирования". 

Это та часть языка, которая относится к применению конструкций `async-await`.

Для выполнения параллельных задач вводится `Task` и `TaskGroup`.

__Задача__: загрузить большое количество маленьких изображений (thumbnail). 

Здесь просто вызовом async метода в URLSession не обойдёшься.

Нужно использовать таски.

## Что такое Task?

Task предоставляет новый _асинхронный контекст_ для выполнения кода "конкурентным образом" ("одновременно", concurrently). 

Каждый таск выполняется конкурентно и с учётом других контекстов выполнения. Они автоматически ставятся в расписание для параллельного выполнения, если это безопасно и эффективно.

При простом вызове async-функции новый таск не создаётся. Таски создаёт сам программист явным образом.

Есть несколько разновидностей тасков. Простейший вид таска – __async-let таск__

## Async-let таски

Для создания этих тасков используется такая конструкция языка swift как _async-let binding_.

```swift
async let result = URLSession.shared.data(...)
```

Разбор этой конструкции существенно отличается от разбора стандартного последовательного кода.

Для разбора этого concurrent binding (async let) язык swift создаст child-таск от того таска, в котором он создаётся (т.е. того, в котором выполняются предшествующие стейтменты).

Пока child таск загружает данные, родительский таск продолжает выполнение следующих инструкций.

Родительский таск будет ожидать результата работы child таска в тот момент, когда появится конструкция `try await result`.

## Task tree

Таски образуют иерархию – __task tree__.

Дерево тасков обрабатывает отмену заданий, их приоритет и локальные переменные таска.

При вызове одной асинхронной функции из другой для выполнения вызова используется один и тот же таск.

Таски не являются чайлдами конкретной функции, но их время жизни может быть привязано к scope некоторой функции.

Связи в дереве тасков обеспечивают правило, что родительский таск может завершить работу только если всего его чайлд-таски завершили работу.

Это правило выполняется даже в случае нестандартной работы потока управления – например, в рассматриваемом родительский таск запускает 2 задачи в соответствующих чайлд-тасках, и первая задача выбрасывает ошибку, то второй таск автоматически помечается как отменённый. Отмена не означает прерывание или остановку таска, она означает только, что результат работы данного таска уже не нужен.

Если таск отменяется, то все его сабтаски отменяются автоматически.

## Остановка таска

Когда она происходит?

Если таск находится посередине важной транзакции или имеет открытые соединения, то было бы неправильно просто остановить таск.

Поэтому таски отменяются согласованным (cooperative) образом.

В коде вы должны в явном виде проверить таск на состояние отмены и свернуть выполнение таким способом, который подходит в данном случае. 

Проверку текущего таска на отмену можно сделать из любой функции, асинхронной и нет.

Проектировать свой код надо с учётом возможности ситуации отмены таска. Пользователи могут вызвать текущий код из таска, который отменен, и тогда они ожидают, что вычисления в данном случае будут прекращены настолько быстро, насколько это возможно.

На пример загрузки миниатюр

```swift
func foo(...) async throws -> [String: UIImage] {
  // ...
  for id in ids {
    try Task.checkCancellation() // Проверка, вызвана ли foo() из таска, который отменен.
                                 // Тогда мы не хотим продолжения загрузки ненужных картинок.
    // ...
  }
  // ... 
}
```

Либо можно использовать свойство `Task.isCancelled`. Тогда вместо выброшенной ошибки ф-я вернет частичный результат загрузки картинок. Это различие между двумя результатами должно быть открыто сформулировано в вашем API, которое вы разрабатываете.

То есть либо вы допускаете частичный результат, либо должен быть получен только полный результат (если его нет, то ошибка).

## Group task

Другой вид тасков. Более гибкий, чем async-let, и удовлетворяющий structured concurrency.

async let подходит для случая фиксированного количества параллелизма. Например, если создаются ровно 2 параллельные подзадачи для загрузки одной картинки.

Если нужно параллельно загрузить N картинок, то здесь нужен group task. Для динамического количества параллелизма.

Создается с помощью функции `withThrowingTaskGroup(...) { group in ... }`.

Имеем scoped объект group, позволяющий создавать чайлд таски (которые могут выбрасывать ошибки). 

Эти сабтаски не могут пережить время жизни блока, в котором определен объект group.

Чайлд таск создается вызовом `group.async { ... }` <–– внутри блока выполняется код подзадачи.

```swift
for id in ids {
  group.async {
    return (id, try await foo(withId: id))
  }
}

// Новый for await цикл выполняется последовательно, поэтому запись безопасна.
for try await (id, img) in group {
  dict[id] = img
}
```

При добавлении в группу чайлд таски начинают выполняться немедленно и в любом порядке.

При выходе объекта group из области видимости, завершение всех сабтасков будет неявно ожидаться.

В пределах group тасков можно использовать async let таски. И наоборот, создавать group task внутри async let таска.

for await цикл используется для доступа к асинхронной последовательности значений. Если ваш тип реализует `AsyncSequence`, то вы тоже можете использовать этот цикл. (_WWDC. Meet AsyncSequence_).

Таск group – часть structured concurrency, но есть небольшое различие между ними и async-let тасками в плане реализации правил дерева тасков. Предположим, при итерации в вышеизложенном цикле `for try await` встречается чайлд таск, завершающийся ошибкой. Поскольку ошибка выбрасывается из блока группы, то все таски в группе будут неявно отменены, а затем для них будет сделан await. Здесь различий с поведением async let тасков нет. Различие с async let тасками будет в случае, если group task выйдет из области видимости нормальным образом (просто покинет блок). Тогда отмена не будет явной. Такое поведение позволяет Вам проще реализовать паттерн fork-join используя групп-таск, поскольку их задания будут только в ситуации ожидания результата (_awaited_), но не отменены. Также вы можете отменить все таски перед выходом из блока с помощью метода `group.cancellAll()`. При этом отмена тоже распространится вниз по дереву тасков.

## @Sendable closure

Это новый тип кложуры, внутри которой выполняется рабочий код таска.

Тело @Sendable closure ограничивает захват мутабельных переменных в своём лексическом контексте. Потому что значения этих переменных могут измениться после того, как таск запущен.

Поэтому захват переменных должен осуществлять только для value-типов, акторов или классов, реализующих свою собственную синхронизацию данных. Это должны быть данные, которые безопасны для шаринга. (_WWDC, Protect mutable state with Swift actors_).

К стандартным коллекциям нельзя обращаться одновременно из разных потоков, это может привести к повреждению данных или крэшу приложения.

## Unstructured tasks

Async let и group таски – это scoped structured таски, в отличие от unstructured tasks.

Но не всегда есть иерархия тасков при добавлении новых тасков в программу.

Unstructured таски дают больше гибкости ценой необходимости ручного управления.

Ситуации, когда не ясной иерархии тасков:

* Когда родительского таска нет вообще, например, асинхронный код запускается из неасинхронного контекста.
* Если требуется, чтобы время жизни таска было больше времени жизни определенного scope. _Например_, вы хотите запустить таск в ответ на вызов метода, который приводит некоторый объект в активное состояние, а затем отменить его выполнение в ответ на вызов другого метода, который деактивирует данный объект.

Пример: делегат `willDisplay cell` для `UICollectionView`.

```swift
@MainActor
class SomeClass {

  var someTasks: [IndexPath: Task<Void, Never>] = [:]

  func someDelegate(...) {
    // ...
    someTasks[indexPath] = Task {
      // do sth...
    }
  }

  // didEndDisplay
  func foo() {
    someTasks[indexPath]?.cancel()
  }
}
```

При достижении данного таска система поместит его в расписание для того же актора, который относится к исходному scope (в данном случае это main actor).

Поток управления немедленно вернется вызывающей стороне, а таск по получению картинки будет выполняться на главном потоке, когда появится возможность его выполнять, при этом не блокируя главный поток сразу в методе делегата.

Unstructured таск

* Наследует изоляцию актора и приоритет (и другие особенности) исходного контекста.
* время жизни не заключено в какой-либо scope.
* Могут быть запущены из любого места, даже не async функций.
* Отмена и ожидание результата должны быть реализованы руками.

## Detached таски

Почти во всём как unstructured таск, но для максимальной гибкости, когда не нужно ничего наследовать от исходного контекста (актор, приоритет и т.д.). 

Приоритет и другие особенности задаются через опциональные параметры.

Пример задачи для detached таска: кэширование полученных картинок, для этого не нужен main actor.

```swift
Task.detached(priority: .background) {
  writeToLocalCache(imgs)
}
```

Внутри detached таска можно использовать structured таски, что воспользоваться их возможностями. Например, задать таск группу, которая выполняет ряд задач, вместо того, что создавать по отдельному таску для каждой задачи.

