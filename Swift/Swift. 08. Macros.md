# Swift. Macros.

Макросы появились в Swift 5.9 как средство против повторяющегося бойлерплейт-кода.

С применением макросов такой код генерируется на этапе компиляции, что позволяет сделать код проекта более выразительным и лёгким в чтении.

## Обзор макросов Swift.

Пусть есть список вычислений, который нужно выполнить студентам:

```swift
let calculations = [
    (1 + 2, "1 + 2"),
    (5 - 3, "5 - 3"),
    (7 * 4, "7 * 4")
]
```

Это повторяющийся код, содержащий дублирование, и он подвержен ошибкам. Поэтому можно определить специальный макрос `#stringify`, позволяющий устранить эту проблему:

```swift
let calculations = [
    #stringify(1 + 2),
    #stringify(5 - 3),
    #stringify(7 * 4)
]
```

(макрос `#stringify` есть в Xcode template - ??).

`#stringify` получает вычисление (число типа `Int`) и создаёт кортеж (как в первом варианте). Заметим, что он выглядит практически как функция, но работает во время компиляции.

```swift
@freestanding(expression)
macro stringify(_ value: Int) -> (Int, String)
```

Макросы могут быть генериками.

Макрос `#stringify` по смыслу является expression'ом (см. `@freestanding(expression)`), поэтому его можно поставить в любом месте, где можно написать expression.

Другой тип макросов - __прикрепляемые макросы__, которые могут аугментировать объявление.

## Раскрытие макроса

Выполняется компилятором после проверки параметров макроса. 

Для каждого макроса есть его реализация в виде плагина компилятора.

Реализация макроса сама является программой на Swift и может делать что угодно.

## Создание макроса

```swift
let a = 17
let b = 25

let (result, code) = #stringify(a + b)
```

Макрос можно раскрыть через контекстное меню Xcode.

Реализация:

```swift
@freestanding(expression)
public macro stringify<T>(_ value: T) -> (T, String) = 
    #externalMacro(module: "SomeModule", type: "StringifyMacro")
```

`#externalMacro` означает, что реализацию макроса компилятор должен искать в типе `StringifyMacro` в модуле `SomeModule`.

```swift
public struct StringifyMacro: ExpressionMacro {

    public static func expansion(
        of node: some FreestandingMacroExpressionSyntax,
        in context: some MacroExpressionContext
    ) -> ExprSyntax {
        guard let argument = node.argumentList.first?.expression else {
            fatalError("compiler bug: the macro does not have any arguments.")
        }

        // Возвращаем тот самый кортеж, который хотим получить:
        return "(\(argument), \(literal: argument.description))"
    }
}
```

`ExpressionMacro` - протокол для макросов, объявленных как `@freestanding(expression)`.

Мы написали наш первый макрос.

Макросы не создают сайд-эффекты.

Работоспособность макросов стоит проверять написанием юнит-тестов для них. Для этого введены специальные ассерты для работы с макросами.

## Зачем нужны макросы?

Далее приводится пример attached макроса, генерирующего конструктор для типа. Однако, в чем в данном случае необходимость этого макроса, почему бы не писать конструкторы обычным способом? 

Видимо, макрос позволяет написать краткую конструкцию `#someMacro()` или `@SomeMacro`, подобную вызову функции или атрибуту, вместо того, чтобы много раз писать повторяющийся код (тот самый бойлерплейт).

Макросы позволяют как бы дополнить функциональность компилятора свифта без необходимости обновлять сам язык программирования.

